"use strict";
(self["webpackChunkapp"] = self["webpackChunkapp"] || []).push([["default-node_modules_sweetalert2_ngx-sweetalert2_fesm2022_sweetalert2-ngx-sweetalert2_mjs"],{

/***/ 54267:
/*!********************************************************************************************!*\
  !*** ./node_modules/@sweetalert2/ngx-sweetalert2/fesm2022/sweetalert2-ngx-sweetalert2.mjs ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SwalComponent: () => (/* binding */ SwalComponent),
/* harmony export */   SwalDirective: () => (/* binding */ SwalDirective),
/* harmony export */   SwalPortalDirective: () => (/* binding */ SwalPortalDirective),
/* harmony export */   SwalPortalTargets: () => (/* binding */ SwalPortalTargets),
/* harmony export */   SweetAlert2LoaderService: () => (/* binding */ SweetAlert2LoaderService),
/* harmony export */   SweetAlert2Module: () => (/* binding */ SweetAlert2Module)
/* harmony export */ });
/* harmony import */ var _Users_eduardoacosta_Documents_GitHub_LideartApp_IONIC_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 71670);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ 61699);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ 72513);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs/operators */ 20274);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/common */ 26575);







function SwalPortalComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementContainer"](0);
  }
}
const swalProviderToken = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('@sweetalert2/ngx-sweetalert2#swalProvider');
const fireOnInitToken = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('@sweetalert2/ngx-sweetalert2#fireOnInit');
const dismissOnDestroyToken = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('@sweetalert2/ngx-sweetalert2#dismissOnDestroy');
class SweetAlert2LoaderService {
  swalProvider;
  swalPromiseCache;
  // Using any because Angular metadata generator does not understand a pure TS type here
  constructor(swalProvider) {
    this.swalProvider = swalProvider;
  }
  get swal() {
    if (!this.swalPromiseCache) {
      this.preloadSweetAlertLibrary();
    }
    return this.swalPromiseCache;
  }
  preloadSweetAlertLibrary() {
    if (this.swalPromiseCache) return;
    const libPromise = isLoader(this.swalProvider) ? this.swalProvider() : Promise.resolve(this.swalProvider);
    this.swalPromiseCache = libPromise.then(value => isDefaultExport(value) ? value : value.default);
    function isLoader(value) {
      return typeof value === 'function' && value.version === undefined;
    }
    function isDefaultExport(value) {
      return typeof value === 'function';
    }
  }
  static ɵfac = function SweetAlert2LoaderService_Factory(t) {
    return new (t || SweetAlert2LoaderService)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](swalProviderToken));
  };
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: SweetAlert2LoaderService,
    factory: SweetAlert2LoaderService.ɵfac
  });
}
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](SweetAlert2LoaderService, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable
  }], function () {
    return [{
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
        args: [swalProviderToken]
      }]
    }];
  }, null);
})();

/**
 * <swal> component. See the README.md for usage.
 *
 * It contains a bunch of @Inputs that have a perfect 1:1 mapping with SweetAlert2 options.
 * Their types are directly coming from SweetAlert2 types defintitions, meaning that ngx-sweetalert2 is tightly coupled
 * to SweetAlert2, but also is type-safe even if both libraries do not evolve in sync.
 *
 * (?) If you want to use an object that declares the SweetAlert2 options all at once rather than many @Inputs,
 *     take a look at [swalOptions], that lets you pass a full {@link SweetAlertOptions} object.
 *
 * (?) If you are reading the TypeScript source of this component, you may think that it's a lot of code.
 *     Be sure that a lot of this code is types and Angular boilerplate. Compiled and minified code is much smaller.
 *     If you are really concerned about performance and/or don't care about the API and its convenient integration
 *     with Angular (notably change detection and transclusion), you may totally use SweetAlert2 natively as well ;)
 *
 * /!\ Some SweetAlert options aren't @Inputs but @Outputs: `willOpen`, `didOpen`, `didRender`, `willClose`, `didClose`
 *     and `didDestroy`.
 *     However, `preConfirm`, `preDeny` and `inputValidator` are still @Inputs because they are not event handlers,
 *     there can't be multiple listeners on them, and we need the values they can/must return.
 */
class SwalComponent {
  sweetAlert2Loader;
  moduleLevelFireOnInit;
  moduleLevelDismissOnDestroy;
  title;
  titleText;
  text;
  html;
  footer;
  icon;
  iconColor;
  iconHtml;
  backdrop;
  toast;
  target;
  input;
  width;
  padding;
  background;
  position;
  grow;
  showClass;
  hideClass;
  customClass;
  timer;
  timerProgressBar;
  heightAuto;
  allowOutsideClick;
  allowEscapeKey;
  allowEnterKey;
  stopKeydownPropagation;
  keydownListenerCapture;
  showConfirmButton;
  showDenyButton;
  showCancelButton;
  confirmButtonText;
  denyButtonText;
  cancelButtonText;
  confirmButtonColor;
  denyButtonColor;
  cancelButtonColor;
  confirmButtonAriaLabel;
  denyButtonAriaLabel;
  cancelButtonAriaLabel;
  buttonsStyling;
  reverseButtons;
  focusConfirm;
  focusDeny;
  focusCancel;
  showCloseButton;
  closeButtonHtml;
  closeButtonAriaLabel;
  loaderHtml;
  showLoaderOnConfirm;
  preConfirm;
  preDeny;
  imageUrl;
  imageWidth;
  imageHeight;
  imageAlt;
  inputLabel;
  inputPlaceholder;
  inputValue;
  inputOptions;
  inputAutoTrim;
  inputAttributes;
  inputValidator;
  returnInputValueOnDeny;
  validationMessage;
  progressSteps;
  currentProgressStep;
  progressStepsDistance;
  scrollbarPadding;
  /**
   * An object of SweetAlert2 native options, useful if:
   *  - you don't want to use the @Inputs for practical/philosophical reasons ;
   *  - there are missing @Inputs because ngx-sweetalert2 isn't up-to-date with SweetAlert2's latest changes.
   *
   * /!\ Please note that setting this property does NOT erase what has been set before unless you specify the
   *     previous properties you want to erase again.
   *     Ie. setting { title: 'Title' } and then { text: 'Text' } will give { title: 'Title', text: 'Text' }.
   *
   * /!\ Be aware that the options defined in this object will override the @Inputs of the same name.
   */
  set swalOptions(options) {
    //=> Update properties
    Object.assign(this, options);
    //=> Mark changed properties as touched
    const touchedKeys = Object.keys(options);
    touchedKeys.forEach(this.markTouched);
  }
  /**
   * Computes the options object that will get passed to SweetAlert2.
   * Only the properties that have been set at least once on this component will be returned.
   * Mostly for internal usage.
   */
  get swalOptions() {
    //=> We will compute the options object based on the option keys that are known to have changed.
    //   That avoids passing a gigantic object to SweetAlert2, making debugging easier and potentially
    //   avoiding side effects.
    return [...this.touchedProps].reduce((obj, key) => ({
      ...obj,
      [key]: this[key]
    }), {});
  }
  /**
   * Whether to fire the modal as soon as the <swal> component is created and initialized in the view.
   * When left undefined (default), the value will be inherited from the module configuration, which is `false`.
   *
   * Example:
   *     <swal *ngIf="error" [title]="error.title" [text]="error.text" icon="error" [swalFireOnInit]="true"></swal>
   */
  swalFireOnInit;
  /**
   * Whether to dismiss the modal when the <swal> component is destroyed by Angular (for any reason) or not.
   * When left undefined (default), the value will be inherited from the module configuration, which is `true`.
   */
  swalDismissOnDestroy;
  set swalVisible(visible) {
    visible ? this.fire() : this.close();
  }
  get swalVisible() {
    return this.isCurrentlyShown;
  }
  /**
   * Modal lifecycle hook. Synchronously runs before the modal is shown on screen.
   */
  willOpen = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();
  /**
   * Modal lifecycle hook. Synchronously runs before the modal is shown on screen.
   */
  didOpen = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();
  /**
   * Modal lifecycle hook. Synchronously runs after the popup DOM has been updated (ie. just before the modal is
   * repainted on the screen).
   * Typically, this will happen after `Swal.fire()` or `Swal.update()`.
   * If you want to perform changes in the popup's DOM, that survive `Swal.update()`, prefer {@link didRender} over
   * {@link willOpen}.
   */
  didRender = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();
  /**
   * Modal lifecycle hook. Synchronously runs when the popup closes by user interaction (and not due to another popup
   * being fired).
   */
  willClose = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();
  /**
   * Modal lifecycle hook. Asynchronously runs after the popup has been disposed by user interaction (and not due to
   * another popup being fired).
   */
  didClose = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();
  /**
   * Modal lifecycle hook. Synchronously runs after popup has been destroyed either by user interaction or by another
   * popup.
   * If you have cleanup operations that you need to reliably execute each time a modal is closed, prefer
   * {@link didDestroy} over {@link didClose}.
   */
  didDestroy = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();
  /**
   * Emits when the user clicks "Confirm".
   * The event value ($event) can be either:
   *  - by default, just `true`,
   *  - when using {@link input}, the input value,
   *  - when using {@link preConfirm}, the return value of this function.
   *
   * Example:
   *     <swal (confirm)="handleConfirm($event)"></swal>
   *
   *     public handleConfirm(email: string): void {
   *         // ... save user email
   *     }
   */
  confirm = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();
  /**
   * Emits when the user clicks "Deny".
   * This event bears no value.
   * Use `(deny)` (along with {@link showDenyButton}) when you want a modal with three buttons (confirm, deny and
   * cancel), and/or when you want to handle clear refusal in a separate way than simple dismissal.
   *
   * Example:
   *     <swal (deny)="handleDeny()"></swal>
   *
   *     public handleDeny(): void {
   *     }
   */
  deny = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();
  /**
   * Emits when the user clicks "Cancel", or dismisses the modal by any other allowed way.
   * The event value ($event) is a string that explains how the modal was dismissed. It is `undefined` when
   * the modal was programmatically closed (through {@link close} for example).
   *
   * Example:
   *     <swal (dismiss)="handleDismiss($event)"></swal>
   *
   *     public handleDismiss(reason: DismissReason | undefined): void {
   *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.
   *         // ... do something
   *     }
   */
  dismiss = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();
  /**
   * This Set retains the properties that have been changed from @Inputs, so we can know precisely
   * what options we have to send to {@link Swal.fire}.
   */
  touchedProps = new Set();
  /**
   * A function of signature `(propName: string): void` that adds a given property name to the list of
   * touched properties, ie. {@link touchedProps}.
   */
  markTouched = this.touchedProps.add.bind(this.touchedProps);
  /**
   * Is the SweetAlert2 modal represented by this component currently opened?
   */
  isCurrentlyShown = false;
  constructor(sweetAlert2Loader, moduleLevelFireOnInit, moduleLevelDismissOnDestroy) {
    this.sweetAlert2Loader = sweetAlert2Loader;
    this.moduleLevelFireOnInit = moduleLevelFireOnInit;
    this.moduleLevelDismissOnDestroy = moduleLevelDismissOnDestroy;
  }
  /**
   * Angular lifecycle hook.
   * Asks the SweetAlert2 loader service to preload the SweetAlert2 library, so it begins to be loaded only if there
   * is a <swal> component somewhere, and is probably fully loaded when the modal has to be displayed,
   * causing no delay.
   */
  ngOnInit() {
    //=> Preload SweetAlert2 library in case this component is activated.
    this.sweetAlert2Loader.preloadSweetAlertLibrary();
  }
  /**
   * Angular lifecycle hook.
   * Fires the modal, if the component or module is configured to do so.
   */
  ngAfterViewInit() {
    const fireOnInit = this.swalFireOnInit === undefined ? this.moduleLevelFireOnInit : this.swalFireOnInit;
    fireOnInit && this.fire();
  }
  /**
   * Angular lifecycle hook.
   * Updates the SweetAlert options, and if the modal is opened, asks SweetAlert to render it again.
   */
  ngOnChanges(changes) {
    //=> For each changed @Input that matches a SweetAlert2 option, mark as touched so we can
    //   send it with the next fire() or update() calls.
    Object.keys(changes)
    //=> If the filtering logic becomes more complex here, we can use Swal.isValidParameter
    .filter(key => !key.startsWith('swal')).forEach(this.markTouched);
    //=> Eventually trigger re-render if the modal is open.
    void this.update();
  }
  /**
   * Angular lifecycle hook.
   * Closes the SweetAlert when the component is destroyed.
   */
  ngOnDestroy() {
    //=> Release the modal if the component is destroyed and if that behaviour is not disabled.
    const dismissOnDestroy = this.swalDismissOnDestroy === undefined ? this.moduleLevelDismissOnDestroy : this.swalDismissOnDestroy;
    dismissOnDestroy && this.close();
  }
  /**
   * Shows the SweetAlert.
   *
   * Returns the SweetAlert2 promise for convenience and use in code behind templates.
   * Otherwise, (confirm)="myHandler($event)" and (dismiss)="myHandler($event)" can be used in templates.
   */
  fire() {
    var _this = this;
    return (0,_Users_eduardoacosta_Documents_GitHub_LideartApp_IONIC_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const swal = yield _this.sweetAlert2Loader.swal;
      const userOptions = _this.swalOptions;
      //=> Build the SweetAlert2 options
      const options = {
        //=> Merge with calculated options set for that specific swal
        ...userOptions,
        //=> Handle modal lifecycle events
        willOpen: composeHook(userOptions.willOpen, modalElement => {
          _this.willOpen.emit({
            modalElement
          });
        }),
        didOpen: composeHook(userOptions.didOpen, modalElement => {
          _this.isCurrentlyShown = true;
          _this.didOpen.emit({
            modalElement
          });
        }),
        didRender: composeHook(userOptions.didRender, modalElement => {
          _this.didRender.emit({
            modalElement
          });
        }),
        willClose: composeHook(userOptions.willClose, modalElement => {
          _this.isCurrentlyShown = false;
          _this.willClose.emit({
            modalElement
          });
        }),
        didClose: composeHook(userOptions.didClose, () => {
          _this.didClose.emit();
        }),
        didDestroy: composeHook(userOptions.didDestroy, () => {
          _this.didDestroy.emit();
        })
      };
      //=> Show the Swal! And wait for confirmation or dimissal.
      const result = yield swal.fire(options);
      //=> Emit on (confirm), (deny) or (dismiss)
      switch (true) {
        case result.isConfirmed:
          _this.confirm.emit(result.value);
          break;
        case result.isDenied:
          _this.deny.emit();
          break;
        case result.isDismissed:
          _this.dismiss.emit(result.dismiss);
          break;
      }
      return result;
      function composeHook(userHook, libHook) {
        return (...args) => (libHook(...args), userHook?.(...args));
      }
    })();
  }
  /**
   * Closes the modal, if opened.
   *
   * @param result The value that the modal will resolve with, triggering either (confirm), (deny) or (dismiss).
   *               If the argument is not passed, it is (dismiss) that will emit an `undefined` reason.
   *               {@see Swal.close}.
   */
  close(result) {
    var _this2 = this;
    return (0,_Users_eduardoacosta_Documents_GitHub_LideartApp_IONIC_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      if (!_this2.isCurrentlyShown) return;
      const swal = yield _this2.sweetAlert2Loader.swal;
      swal.close(result);
    })();
  }
  /**
   * Updates SweetAlert2 options while the modal is opened, causing the modal to re-render.
   * If the modal is not opened, the component options will simply be updated and that's it.
   *
   * /!\ Please note that not all SweetAlert2 options are updatable while the modal is opened.
   *
   * @param options
   */
  update(options) {
    var _this3 = this;
    return (0,_Users_eduardoacosta_Documents_GitHub_LideartApp_IONIC_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      if (options) {
        _this3.swalOptions = options;
      }
      if (!_this3.isCurrentlyShown) return;
      const swal = yield _this3.sweetAlert2Loader.swal;
      const allOptions = _this3.swalOptions;
      const updatableOptions = Object.keys(allOptions).filter(swal.isUpdatableParameter).reduce((obj, key) => ({
        ...obj,
        [key]: allOptions[key]
      }), {});
      swal.update(updatableOptions);
    })();
  }
  static ɵfac = function SwalComponent_Factory(t) {
    return new (t || SwalComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](SweetAlert2LoaderService), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](fireOnInitToken), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](dismissOnDestroyToken));
  };
  static ɵcmp = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineComponent"]({
    type: SwalComponent,
    selectors: [["swal"]],
    inputs: {
      title: "title",
      titleText: "titleText",
      text: "text",
      html: "html",
      footer: "footer",
      icon: "icon",
      iconColor: "iconColor",
      iconHtml: "iconHtml",
      backdrop: "backdrop",
      toast: "toast",
      target: "target",
      input: "input",
      width: "width",
      padding: "padding",
      background: "background",
      position: "position",
      grow: "grow",
      showClass: "showClass",
      hideClass: "hideClass",
      customClass: "customClass",
      timer: "timer",
      timerProgressBar: "timerProgressBar",
      heightAuto: "heightAuto",
      allowOutsideClick: "allowOutsideClick",
      allowEscapeKey: "allowEscapeKey",
      allowEnterKey: "allowEnterKey",
      stopKeydownPropagation: "stopKeydownPropagation",
      keydownListenerCapture: "keydownListenerCapture",
      showConfirmButton: "showConfirmButton",
      showDenyButton: "showDenyButton",
      showCancelButton: "showCancelButton",
      confirmButtonText: "confirmButtonText",
      denyButtonText: "denyButtonText",
      cancelButtonText: "cancelButtonText",
      confirmButtonColor: "confirmButtonColor",
      denyButtonColor: "denyButtonColor",
      cancelButtonColor: "cancelButtonColor",
      confirmButtonAriaLabel: "confirmButtonAriaLabel",
      denyButtonAriaLabel: "denyButtonAriaLabel",
      cancelButtonAriaLabel: "cancelButtonAriaLabel",
      buttonsStyling: "buttonsStyling",
      reverseButtons: "reverseButtons",
      focusConfirm: "focusConfirm",
      focusDeny: "focusDeny",
      focusCancel: "focusCancel",
      showCloseButton: "showCloseButton",
      closeButtonHtml: "closeButtonHtml",
      closeButtonAriaLabel: "closeButtonAriaLabel",
      loaderHtml: "loaderHtml",
      showLoaderOnConfirm: "showLoaderOnConfirm",
      preConfirm: "preConfirm",
      preDeny: "preDeny",
      imageUrl: "imageUrl",
      imageWidth: "imageWidth",
      imageHeight: "imageHeight",
      imageAlt: "imageAlt",
      inputLabel: "inputLabel",
      inputPlaceholder: "inputPlaceholder",
      inputValue: "inputValue",
      inputOptions: "inputOptions",
      inputAutoTrim: "inputAutoTrim",
      inputAttributes: "inputAttributes",
      inputValidator: "inputValidator",
      returnInputValueOnDeny: "returnInputValueOnDeny",
      validationMessage: "validationMessage",
      progressSteps: "progressSteps",
      currentProgressStep: "currentProgressStep",
      progressStepsDistance: "progressStepsDistance",
      scrollbarPadding: "scrollbarPadding",
      swalOptions: "swalOptions",
      swalFireOnInit: "swalFireOnInit",
      swalDismissOnDestroy: "swalDismissOnDestroy",
      swalVisible: "swalVisible"
    },
    outputs: {
      willOpen: "willOpen",
      didOpen: "didOpen",
      didRender: "didRender",
      willClose: "willClose",
      didClose: "didClose",
      didDestroy: "didDestroy",
      confirm: "confirm",
      deny: "deny",
      dismiss: "dismiss"
    },
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵNgOnChangesFeature"]],
    decls: 0,
    vars: 0,
    template: function SwalComponent_Template(rf, ctx) {},
    encapsulation: 2,
    changeDetection: 0
  });
}
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](SwalComponent, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Component,
    args: [{
      selector: 'swal',
      template: '',
      changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__.ChangeDetectionStrategy.OnPush
    }]
  }], function () {
    return [{
      type: SweetAlert2LoaderService
    }, {
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
        args: [fireOnInitToken]
      }]
    }, {
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
        args: [dismissOnDestroyToken]
      }]
    }];
  }, {
    title: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    titleText: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    text: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    html: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    footer: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    icon: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    iconColor: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    iconHtml: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    backdrop: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    toast: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    target: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    input: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    width: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    padding: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    background: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    position: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    grow: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    showClass: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    hideClass: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    customClass: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    timer: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    timerProgressBar: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    heightAuto: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    allowOutsideClick: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    allowEscapeKey: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    allowEnterKey: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    stopKeydownPropagation: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    keydownListenerCapture: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    showConfirmButton: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    showDenyButton: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    showCancelButton: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    confirmButtonText: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    denyButtonText: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    cancelButtonText: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    confirmButtonColor: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    denyButtonColor: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    cancelButtonColor: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    confirmButtonAriaLabel: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    denyButtonAriaLabel: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    cancelButtonAriaLabel: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    buttonsStyling: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    reverseButtons: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    focusConfirm: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    focusDeny: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    focusCancel: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    showCloseButton: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    closeButtonHtml: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    closeButtonAriaLabel: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    loaderHtml: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    showLoaderOnConfirm: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    preConfirm: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    preDeny: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    imageUrl: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    imageWidth: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    imageHeight: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    imageAlt: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    inputLabel: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    inputPlaceholder: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    inputValue: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    inputOptions: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    inputAutoTrim: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    inputAttributes: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    inputValidator: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    returnInputValueOnDeny: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    validationMessage: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    progressSteps: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    currentProgressStep: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    progressStepsDistance: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    scrollbarPadding: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    swalOptions: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    swalFireOnInit: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    swalDismissOnDestroy: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    swalVisible: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    willOpen: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Output
    }],
    didOpen: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Output
    }],
    didRender: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Output
    }],
    willClose: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Output
    }],
    didClose: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Output
    }],
    didDestroy: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Output
    }],
    confirm: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Output
    }],
    deny: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Output
    }],
    dismiss: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Output
    }]
  });
})();

/**
 * [swal] directive. It takes a value that defines the SweetAlert and can be of three types:
 *
 * 1) A simple array of two or three strings defining [title, text, icon] - the icon being optional, ex:
 *
 *    <button [swal]="['Title', 'Text']">Click me</button>
 *
 * 2) A native SweetAlert2 options object, ex:
 *
 *    <button [swal]="{ title: 'Title', text: 'Text' }">Click me</button>
 *
 * 3) A reference to an existing SwalComponent instance for more advanced uses, ex:
 *
 *    <button [swal]="mySwal">Click me</button>
 *    <swal #mySwal title="Title" text="Text"></swal>
 */
class SwalDirective {
  viewContainerRef;
  resolver;
  /**
   * SweetAlert2 options or a SwalComponent instance.
   * See the class doc block for more informations.
   */
  set swal(options) {
    if (options instanceof SwalComponent) {
      this.swalInstance = options;
    } else if (isArrayOptions(options)) {
      this.swalOptions = {};
      [this.swalOptions.title, this.swalOptions.text, this.swalOptions.icon] = options;
    } else {
      this.swalOptions = options;
    }
    function isArrayOptions(value) {
      return Array.isArray(options);
    }
  }
  /**
   * Emits when the user clicks "Confirm".
   * The event value ($event) can be either:
   *  - by default, just `true`,
   *  - when using {@link input}, the input value,
   *  - when using {@link preConfirm}, the return value of this function.
   *
   * Example:
   *     <swal (confirm)="handleConfirm($event)"></swal>
   *
   *     public handleConfirm(email: string): void {
   *         // ... save user email
   *     }
   */
  confirm = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();
  /**
   * Emits when the user clicks "Deny".
   * This event bears no value.
   * Use `(deny)` (along with {@link showDenyButton}) when you want a modal with three buttons (confirm, deny and
   * cancel), and/or when you want to handle clear refusal in a separate way than simple dismissal.
   *
   * Example:
   *     <swal (deny)="handleDeny()"></swal>
   *
   *     public handleDeny(): void {
   *     }
   */
  deny = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();
  /**
   * Emits when the user clicks "Cancel", or dismisses the modal by any other allowed way.
   * The event value ($event) is a string that explains how the modal was dismissed. It is `undefined` when
   * the modal was programmatically closed (through {@link dismiss} for example).
   *
   * Example:
   *     <swal (dismiss)="handleDismiss($event)"></swal>
   *
   *     public handleDismiss(reason: DismissReason | undefined): void {
   *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.
   *         // ... do something
   *     }
   */
  dismiss = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();
  /**
   * When the user does not provides a SwalComponent instance, we create it on-the-fly and assign the plain-object
   * options to it.
   * This fields keeps a reference to the dynamically-created <swal>, to destroy it along this directive instance.
   */
  swalRef;
  /**
   * An instance of the <swal> component that this directive controls.
   * Could be an instance passed by the user, otherwise it's the instance we've dynamically created.
   */
  swalInstance;
  /**
   * Holds the native SweetAlert2 options.
   * Empty when the user passed an existing SwalComponent instance.
   */
  swalOptions;
  constructor(viewContainerRef, resolver) {
    this.viewContainerRef = viewContainerRef;
    this.resolver = resolver;
  }
  /**
   * OnInit lifecycle handler.
   * Creates a SwalComponent instance if the user didn't provided one and binds on that component (confirm),
   * (deny) and (dismiss) outputs to reemit on the directive.
   */
  ngOnInit() {
    if (!this.swalInstance) {
      const factory = this.resolver.resolveComponentFactory(SwalComponent);
      this.swalRef = this.viewContainerRef.createComponent(factory);
      this.swalInstance = this.swalRef.instance;
    }
  }
  /**
   * OnDestroy lifecycle handler.
   * Destroys the dynamically-created SwalComponent.
   */
  ngOnDestroy() {
    if (this.swalRef) {
      this.swalRef.destroy();
    }
  }
  /**
   * Click handler.
   * The directive listens for onclick events on its host element.
   * When this happens, it shows the <swal> attached to this directive.
   */
  onClick(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    event.stopPropagation();
    if (!this.swalInstance) return;
    if (this.swalOptions) {
      this.swalInstance.swalOptions = this.swalOptions;
    }
    const swalClosed = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();
    this.swalInstance.confirm.asObservable().pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(swalClosed)).subscribe(v => this.confirm.emit(v));
    this.swalInstance.deny.asObservable().pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(swalClosed)).subscribe(v => this.deny.emit(v));
    this.swalInstance.dismiss.asObservable().pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(swalClosed)).subscribe(v => this.dismiss.emit(v));
    this.swalInstance.fire().then(() => swalClosed.next());
  }
  static ɵfac = function SwalDirective_Factory(t) {
    return new (t || SwalDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.ViewContainerRef), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.ComponentFactoryResolver));
  };
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: SwalDirective,
    selectors: [["", "swal", ""]],
    hostBindings: function SwalDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵlistener"]("click", function SwalDirective_click_HostBindingHandler($event) {
          return ctx.onClick($event);
        });
      }
    },
    inputs: {
      swal: "swal"
    },
    outputs: {
      confirm: "confirm",
      deny: "deny",
      dismiss: "dismiss"
    }
  });
}
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](SwalDirective, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: '[swal]'
    }]
  }], function () {
    return [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.ViewContainerRef
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.ComponentFactoryResolver
    }];
  }, {
    swal: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }],
    confirm: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Output
    }],
    deny: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Output
    }],
    dismiss: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Output
    }],
    onClick: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.HostListener,
      args: ['click', ['$event']]
    }]
  });
})();

/**
 * @internal
 * Holds a consumer's Angular template and displays it on a Sweet Alert.
 * See SwalPortalDirective for info about the covered feature.
 */
class SwalPortalComponent {
  template = null;
  static ɵfac = function SwalPortalComponent_Factory(t) {
    return new (t || SwalPortalComponent)();
  };
  static ɵcmp = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineComponent"]({
    type: SwalPortalComponent,
    selectors: [["swal-portal"]],
    inputs: {
      template: "template"
    },
    decls: 1,
    vars: 1,
    consts: [[4, "ngTemplateOutlet"]],
    template: function SwalPortalComponent_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplate"](0, SwalPortalComponent_ng_container_0_Template, 1, 0, "ng-container", 0);
      }
      if (rf & 2) {
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("ngTemplateOutlet", ctx.template);
      }
    },
    dependencies: [_angular_common__WEBPACK_IMPORTED_MODULE_4__.NgTemplateOutlet],
    encapsulation: 2,
    changeDetection: 0
  });
}
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](SwalPortalComponent, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Component,
    args: [{
      selector: 'swal-portal',
      template: '<ng-container *ngTemplateOutlet="template"></ng-container>',
      changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__.ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    template: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input
    }]
  });
})();

/**
 * Represents an object of targets for <swal> portals (use with *swalPortal directive).
 * We must use thunks to access the Swal.* functions listed below, because they get created after the first modal is
 * shown, so this object lets us reference those functions safely and in a statically-typed manner.
 */
class SwalPortalTargets {
  /**
   * Targets the modal close button block contents.
   */
  closeButton = {
    element: swal => swal.getCloseButton(),
    options: {
      showCloseButton: true
    }
  };
  /**
   * Targets the modal title block contents.
   */
  title = {
    element: swal => swal.getTitle(),
    // Empty text that will never be shown but necessary so SweetAlert2 makes the div visible.
    options: {
      title: ' '
    }
  };
  /**
   * Targets the modal text block contents (that is another block inside the first content block, so you can still
   * use other modal features like Swal inputs, that are situated inside that parent content block).
   */
  content = {
    element: swal => swal.getHtmlContainer(),
    // Empty text that will never be shown but necessary so SweetAlert2 makes the div visible.
    options: {
      text: ' '
    }
  };
  /**
   * Targets the actions block contents, where are the confirm and cancel buttons in a normal time.
   * /!\ WARNING: using this target destroys some of the native SweetAlert2 modal's DOM, therefore, if you use this
   *     target, do not update the modal via <swal> @Inputs while the modal is open, or you'll get an error.
   *     We could workaround that inconvenient inside this integration, but that'd be detrimental to memory and
   *     performance of everyone, for a relatively rare use case.
   */
  actions = {
    element: swal => swal.getActions(),
    // The button will never exist, but SweetAlert2 shows the actions block only if there is at least one button.
    options: {
      showConfirmButton: true
    }
  };
  /**
   * Targets the confirm button contents, replacing the text inside it (not the button itself)
   */
  confirmButton = {
    element: swal => swal.getConfirmButton(),
    options: {
      showConfirmButton: true
    }
  };
  /**
   * Targets the deny button contents, replacing the text inside it (not the button itself)
   */
  denyButton = {
    element: swal => swal.getDenyButton(),
    options: {
      showDenyButton: true
    }
  };
  /**
   * Targets the cancel button contents, replacing the text inside it (not the button itself)
   */
  cancelButton = {
    element: swal => swal.getCancelButton(),
    options: {
      showCancelButton: true
    }
  };
  /**
   * Targets the modal footer contents.
   */
  footer = {
    element: swal => swal.getFooter(),
    // Empty text that will never be shown but necessary so SweetAlert2 makes the div visible.
    options: {
      footer: ' '
    }
  };
  static ɵfac = function SwalPortalTargets_Factory(t) {
    return new (t || SwalPortalTargets)();
  };
  static ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: SwalPortalTargets,
    factory: SwalPortalTargets.ɵfac,
    providedIn: 'root'
  });
}
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](SwalPortalTargets, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], null, null);
})();

/**
 * A structural directive that lets you use Angular templates inside of SweetAlerts.
 * There are different targetable zones provided by {@link SwalPortalTargets}: title, content, confirmButton, etc, but
 * you can also make your own target by implementing {@link SwalPortalTarget} and giving it to this directive.
 * The default target is the alert text content zone.
 *
 * Usage in your component's TypeScript (if you use another target than {@link SwalPortalTargets.content}):
 *
 *     @Component({ ... })
 *     export class MyComponent {
 *         public constructor(public readonly swalTargets: SwalPortalTargets) {
 *         }
 *     }
 *
 * Usage in the template:
 *
 *     <swal title="Fill the form" (confirm)="confirmHandler()">
 *         <!-- This form will be displayed as the alert main content
 *              Targets the alert's main content zone by default -->
 *         <form *swalPortal [formControl]="myForm">
 *             ...
 *         </form>
 *
 *         <!-- This targets the confirm button's inner content
 *              Notice the usage of ng-container to avoid creating an useless DOM element inside the button -->
 *         <ng-container *swalPortal="swalTargets.confirmButton">
 *              Send ({{ secondsLeft }} seconds left)
 *         </ng-container>
 *     <swal>
 */
class SwalPortalDirective {
  resolver;
  injector;
  app;
  templateRef;
  sweetAlert2Loader;
  swalTargets;
  swalComponent;
  /**
   * Takes a portal target or nothing (then it will target the text content zone by default).
   *
   * See the {@link SwalPortalTargets} service to see the available targets.
   * See the class doc block for more informations.
   */
  target;
  /**
   * Holds the component reference of the controlled SwalPortalComponent to destroy it when no longer needed.
   */
  portalComponentRef;
  destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();
  constructor(resolver, injector, app, templateRef, sweetAlert2Loader, swalTargets, swalComponent) {
    this.resolver = resolver;
    this.injector = injector;
    this.app = app;
    this.templateRef = templateRef;
    this.sweetAlert2Loader = sweetAlert2Loader;
    this.swalTargets = swalTargets;
    this.swalComponent = swalComponent;
  }
  /**
   * Subscribes to the the SweetAlert appearance/disappearance events to create/destroy the SwalPortalComponent
   * that will receive the consumer's template.
   */
  ngOnInit() {
    // Can't be set in a default property value, if the customer lets *swalPortal empty, the value we get is undef.
    this.target = this.target || this.swalTargets.content;
    //=> Apply the options provided by the target definition
    void this.swalComponent.update(this.target.options);
    //=> Subscribe to a few hooks frm the parent SwalComponent.
    this.swalComponent.didRender.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(this.destroyed)).subscribe(this.didRenderHook.bind(this));
    this.swalComponent.willOpen.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(this.destroyed)).subscribe(this.willOpenHook.bind(this));
    this.swalComponent.didDestroy.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(this.destroyed)).subscribe(this.didDestroyHook.bind(this));
  }
  /**
   * Signal any {@link destroyed} consumer that this is over, so they can unsubscribe from the
   * parent SwalComponent events.
   */
  ngOnDestroy() {
    this.destroyed.next();
  }
  /**
   * This didRender hook runs 1..n times (per modal instance), just before the modal is shown (and also before the
   * {@link willOpenHook}), or after Swal.update() is called.
   * This is a good place to render, or re-render, our portal contents.
   */
  didRenderHook() {
    var _this4 = this;
    return (0,_Users_eduardoacosta_Documents_GitHub_LideartApp_IONIC_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      //=> Ensure the portal component is created
      if (!_this4.portalComponentRef) {
        _this4.portalComponentRef = _this4.createPortalComponent();
      }
      //=> SweetAlert2 created the modal or just erased all of our content, so we need to install/reinstall it.
      // Swal.update() is synchronous, this observable too, and mountComponentOnTarget too (the promise inside
      // this function is already resolved at this point), so the whole process of re-rendering and re-mounting
      // the portal component is fully synchronous, causing no blinks in the modal contents.
      const swal = yield _this4.sweetAlert2Loader.swal;
      //=> Find target element
      const targetEl = _this4.target.element(swal);
      if (!targetEl) return;
      //=> Replace target's contents with our component
      // https://jsperf.com/innerhtml-vs-removechild/15
      while (targetEl.firstChild) {
        targetEl.removeChild(targetEl.firstChild);
      }
      targetEl.appendChild(_this4.portalComponentRef.location.nativeElement);
    })();
  }
  /**
   * This willOpen hook runs once (per modal instance), just before the modal is shown on the screen.
   * This is a good place to declare our detached view to the Angular app.
   */
  willOpenHook() {
    if (!this.portalComponentRef) return;
    //=> Make the Angular app aware of that detached view so rendering and change detection can happen
    this.app.attachView(this.portalComponentRef.hostView);
  }
  /**
   * This didDestroy hook runs once (per modal instance), just after the modal closing animation terminated.
   * This is a good place to detach and destroy our content, that is not visible anymore.
   */
  didDestroyHook() {
    if (!this.portalComponentRef) return;
    //=> Detach the portal component from the app and destroy it
    this.app.detachView(this.portalComponentRef.hostView);
    this.portalComponentRef.destroy();
    this.portalComponentRef = void 0;
  }
  /**
   * Creates the {@link SwalPortalComponent} and gives it the customer's template ref.
   */
  createPortalComponent() {
    //=> Create the SwalPortalComponent that will hold our content
    const factory = this.resolver.resolveComponentFactory(SwalPortalComponent);
    // Yes, we do not use the third argument that would directly use the target as the component's view
    // (unfortunately, because that would give a cleaner DOM and would avoid dirty and direct DOM manipulations)
    // That's because we want to keep our component safe from SweetAlert2's operations on the DOM, and to be
    // able to restore it at any moment, ie. after the modal has been re-rendered.
    const componentRef = factory.create(this.injector, []);
    //=> Apply the consumer's template on the component
    componentRef.instance.template = this.templateRef;
    return componentRef;
  }
  static ɵfac = function SwalPortalDirective_Factory(t) {
    return new (t || SwalPortalDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.ComponentFactoryResolver), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.Injector), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.ApplicationRef), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.TemplateRef), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](SweetAlert2LoaderService), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](SwalPortalTargets), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](SwalComponent, 1));
  };
  static ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: SwalPortalDirective,
    selectors: [["", "swalPortal", ""]],
    inputs: {
      target: ["swalPortal", "target"]
    }
  });
}
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](SwalPortalDirective, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: '[swalPortal]'
    }]
  }], function () {
    return [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.ComponentFactoryResolver
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injector
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.ApplicationRef
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.TemplateRef
    }, {
      type: SweetAlert2LoaderService
    }, {
      type: SwalPortalTargets
    }, {
      type: SwalComponent,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Host
      }]
    }];
  }, {
    target: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input,
      args: ['swalPortal']
    }]
  });
})();
function provideDefaultSwal() {
  return __webpack_require__.e(/*! import() */ "default-node_modules_sweetalert2_dist_sweetalert2_all_js").then(__webpack_require__.t.bind(__webpack_require__, /*! sweetalert2 */ 27889, 19));
}
class SweetAlert2Module {
  static forRoot(options = {}) {
    return {
      ngModule: SweetAlert2Module,
      providers: [SweetAlert2LoaderService, {
        provide: swalProviderToken,
        useValue: options.provideSwal || provideDefaultSwal
      }, {
        provide: fireOnInitToken,
        useValue: options.fireOnInit || false
      }, {
        provide: dismissOnDestroyToken,
        useValue: options.dismissOnDestroy || true
      }]
    };
  }
  static forChild(options = {}) {
    return {
      ngModule: SweetAlert2Module,
      providers: [...(options.provideSwal ? [SweetAlert2LoaderService, {
        provide: swalProviderToken,
        useValue: options.provideSwal
      }] : []), ...(options.fireOnInit !== undefined ? [{
        provide: fireOnInitToken,
        useValue: options.fireOnInit
      }] : []), ...(options.dismissOnDestroy !== undefined ? [{
        provide: dismissOnDestroyToken,
        useValue: options.dismissOnDestroy
      }] : [])]
    };
  }
  static ɵfac = function SweetAlert2Module_Factory(t) {
    return new (t || SweetAlert2Module)();
  };
  static ɵmod = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineNgModule"]({
    type: SweetAlert2Module,
    declarations: [SwalDirective, SwalComponent, SwalPortalDirective, SwalPortalComponent],
    imports: [_angular_common__WEBPACK_IMPORTED_MODULE_4__.CommonModule],
    exports: [SwalComponent, SwalPortalDirective, SwalDirective]
  });
  static ɵinj = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"]({
    imports: [_angular_common__WEBPACK_IMPORTED_MODULE_4__.CommonModule]
  });
}
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](SweetAlert2Module, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgModule,
    args: [{
      declarations: [SwalDirective, SwalComponent, SwalPortalDirective, SwalPortalComponent],
      imports: [_angular_common__WEBPACK_IMPORTED_MODULE_4__.CommonModule],
      exports: [SwalComponent, SwalPortalDirective, SwalDirective]
    }]
  }], null, null);
})();

/**
 * Generated bundle index. Do not edit.
 */



/***/ })

}]);
//# sourceMappingURL=default-node_modules_sweetalert2_ngx-sweetalert2_fesm2022_sweetalert2-ngx-sweetalert2_mjs.js.map